-- Generated by Ora2Pg, the Oracle database Schema converter, version 21.1
-- Copyright 2000-2020 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:INT8R

SET client_encoding TO 'UTF8';

SET search_path = doma_pandabigmon,public;
\set ON_ERROR_STOP ON

SET check_function_bodies = false;

DROP TRIGGER IF EXISTS auth_group_permissions_tr ON auth_group_permissions CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_group_permissions_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_group_permissions_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_group_permissions_tr() OWNER TO panda;

CREATE TRIGGER auth_group_permissions_tr
BEFORE INSERT ON auth_group_permissions FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_group_permissions_tr();

DROP TRIGGER IF EXISTS auth_group_tr ON auth_group CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_group_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_group_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_group_tr() OWNER TO panda;

CREATE TRIGGER auth_group_tr
BEFORE INSERT ON auth_group FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_group_tr();

DROP TRIGGER IF EXISTS auth_permission_tr ON auth_permission CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_permission_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_permission_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_permission_tr() OWNER TO panda;

CREATE TRIGGER auth_permission_tr
BEFORE INSERT ON auth_permission FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_permission_tr();

DROP TRIGGER IF EXISTS auth_user_groups_tr ON auth_user_groups CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_user_groups_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_user_groups_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_user_groups_tr() OWNER TO panda;

CREATE TRIGGER auth_user_groups_tr
BEFORE INSERT ON auth_user_groups FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_user_groups_tr();

DROP TRIGGER IF EXISTS auth_user_tr ON auth_user CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_user_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_user_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_user_tr() OWNER TO panda;

CREATE TRIGGER auth_user_tr
BEFORE INSERT ON auth_user FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_user_tr();

DROP TRIGGER IF EXISTS auth_user_user_permissi17f3 ON auth_user_user_permissions CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_user_user_permissi17f3() RETURNS trigger AS $BODY$
BEGIN
        SELECT auth_user_user_permissi7b1e.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_user_user_permissi17f3() OWNER TO panda;

CREATE TRIGGER auth_user_user_permissi17f3
BEFORE INSERT ON auth_user_user_permissions FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_auth_user_user_permissi17f3();

DROP TRIGGER IF EXISTS django_admin_log_tr ON django_admin_log CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_django_admin_log_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT django_admin_log_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_django_admin_log_tr() OWNER TO panda;

CREATE TRIGGER django_admin_log_tr
BEFORE INSERT ON django_admin_log FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_django_admin_log_tr();

DROP TRIGGER IF EXISTS django_content_type_tr ON django_content_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_django_content_type_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT django_content_type_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_django_content_type_tr() OWNER TO panda;

CREATE TRIGGER django_content_type_tr
BEFORE INSERT ON django_content_type FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_django_content_type_tr();

DROP TRIGGER IF EXISTS django_migrations_tr ON django_migrations CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_django_migrations_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT django_migrations_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_django_migrations_tr() OWNER TO panda;

CREATE TRIGGER django_migrations_tr
BEFORE INSERT ON django_migrations FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_django_migrations_tr();

DROP TRIGGER IF EXISTS preprocess_groupskeys_trg ON preprocess_groupskeys CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_preprocess_groupskeys_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND coalesce(NEW.ID::text, '') = '' THEN
      SELECT nextval('preprocess_groupskeys_seq') INTO STRICT NEW.ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_preprocess_groupskeys_trg() OWNER TO panda;

CREATE TRIGGER preprocess_groupskeys_trg
	BEFORE INSERT ON preprocess_groupskeys FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_preprocess_groupskeys_trg();

DROP TRIGGER IF EXISTS preprocess_groups_trg ON preprocess_groups CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_preprocess_groups_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND coalesce(NEW.GROUPID::text, '') = '' THEN
      SELECT nextval('preprocess_groups_seq') INTO STRICT NEW.GROUPID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_preprocess_groups_trg() OWNER TO panda;

CREATE TRIGGER preprocess_groups_trg
	BEFORE INSERT ON preprocess_groups FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_preprocess_groups_trg();

DROP TRIGGER IF EXISTS preprocess_jobs_trg ON preprocess_jobs CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_preprocess_jobs_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND coalesce(NEW.ID::text, '') = '' THEN
      SELECT nextval('preprocess_jobs_seq') INTO STRICT NEW.ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_preprocess_jobs_trg() OWNER TO panda;

CREATE TRIGGER preprocess_jobs_trg
	BEFORE INSERT ON preprocess_jobs FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_preprocess_jobs_trg();

DROP TRIGGER IF EXISTS preprocess_queues_trg ON preprocess_queues CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_preprocess_queues_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND coalesce(NEW.PREPTASKID::text, '') = '' THEN
      SELECT nextval('preprocess_queues_seq') INTO STRICT NEW.PREPTASKID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_preprocess_queues_trg() OWNER TO panda;

CREATE TRIGGER preprocess_queues_trg
	BEFORE INSERT ON preprocess_queues FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_preprocess_queues_trg();

DROP TRIGGER IF EXISTS request_stats_trigger ON request_stats CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_request_stats_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('request_stats_seq')
  INTO STRICT   NEW.id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_request_stats_trigger() OWNER TO panda;

CREATE TRIGGER request_stats_trigger
	BEFORE INSERT ON request_stats FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_request_stats_trigger();

DROP TRIGGER IF EXISTS social_auth_association_tr ON social_auth_association CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_association_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT social_auth_association_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_association_tr() OWNER TO panda;

CREATE TRIGGER social_auth_association_tr
BEFORE INSERT ON social_auth_association FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_social_auth_association_tr();

DROP TRIGGER IF EXISTS social_auth_code_tr ON social_auth_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_code_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT social_auth_code_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_code_tr() OWNER TO panda;

CREATE TRIGGER social_auth_code_tr
BEFORE INSERT ON social_auth_code FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_social_auth_code_tr();

DROP TRIGGER IF EXISTS social_auth_nonce_tr ON social_auth_nonce CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_nonce_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT social_auth_nonce_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_nonce_tr() OWNER TO panda;

CREATE TRIGGER social_auth_nonce_tr
BEFORE INSERT ON social_auth_nonce FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_social_auth_nonce_tr();

DROP TRIGGER IF EXISTS social_auth_partial_tr ON social_auth_partial CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_partial_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT social_auth_partial_sq.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_partial_tr() OWNER TO panda;

CREATE TRIGGER social_auth_partial_tr
BEFORE INSERT ON social_auth_partial FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_social_auth_partial_tr();

DROP TRIGGER IF EXISTS social_auth_usersociala1245 ON social_auth_usersocialauth CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_usersociala1245() RETURNS trigger AS $BODY$
BEGIN
        SELECT social_auth_usersociala0419.nextval
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_usersociala1245() OWNER TO panda;

CREATE TRIGGER social_auth_usersociala1245
BEFORE INSERT ON social_auth_usersocialauth FOR EACH ROW
	WHEN (coalesce(new.id::text, '') = '')
	EXECUTE PROCEDURE trigger_fct_social_auth_usersociala1245();

DROP TRIGGER IF EXISTS update_taskbody_modiftime ON panda_tasks_aggr CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_update_taskbody_modiftime() RETURNS trigger AS $BODY$
BEGIN
  NEW.TASKBODY_MODIFTIME := (CURRENT_TIMESTAMP AT TIME ZONE 'UTC');
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_update_taskbody_modiftime() OWNER TO panda;

CREATE TRIGGER update_taskbody_modiftime
	BEFORE UPDATE ON panda_tasks_aggr FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_update_taskbody_modiftime();

DROP TRIGGER IF EXISTS users_bir ON monitor_users CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_users_bir() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('users_seq')
  INTO STRICT   NEW.id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_users_bir() OWNER TO panda;

CREATE TRIGGER users_bir
	BEFORE INSERT ON monitor_users FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_users_bir();

DROP TRIGGER IF EXISTS visits_trigger ON visits CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_visits_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('visits_seq')
  INTO STRICT   NEW.VISITID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_visits_trigger() OWNER TO panda;

CREATE TRIGGER visits_trigger
	BEFORE INSERT ON visits FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_visits_trigger();

